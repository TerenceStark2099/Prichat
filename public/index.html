<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prichat | Secure, Ephemeral, End-to-End Encrypted Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&family=Share+Tech+Mono&display=swap');
        
        :root {
            --neon-green: #00ff7f;
            --dark-bg: #0d1117;
            --glass-bg: rgba(45, 52, 64, 0.4);
        }

        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--dark-bg); 
            color: #e5e7eb; 
            overflow-x: hidden;
            scroll-behavior: smooth; 
        }

        .neon-text { 
            color: var(--neon-green); 
            text-shadow: 0 0 3px var(--neon-green), 0 0 8px rgba(0, 255, 127, 0.6); 
            font-family: 'Share Tech Mono', monospace; 
        }

        .neon-button { 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 0 10px rgba(0, 255, 127, 0.3); 
        }

        .neon-button:hover { 
            background-color: var(--neon-green); 
            color: #0d1117; 
            box-shadow: 0 0 25px var(--neon-green); 
            transform: translateY(-2px); 
        }

        .glass-card { 
            background: var(--glass-bg); 
            backdrop-filter: blur(12px); 
            border: 1px solid rgba(0, 255, 127, 0.15); 
        }

        .hidden { display: none !important; }

        .chat-messages::-webkit-scrollbar { width: 4px; }
        .chat-messages::-webkit-scrollbar-track { background: transparent; }
        .chat-messages::-webkit-scrollbar-thumb { background: var(--neon-green); border-radius: 10px; }

        .message-bubble { 
            max-width: 85%; 
            border-radius: 18px; 
            padding: 10px 16px; 
            margin-bottom: 8px; 
            word-wrap: break-word; 
            position: relative;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-bubble.mine { background: #00a86b; color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
        .message-bubble.other { background: #161b22; color: #e5e7eb; align-self: flex-start; border: 1px solid rgba(0, 255, 127, 0.2); border-bottom-left-radius: 4px; }
    </style>
</head>
<body class="min-h-screen">

    <!-- LANDING VIEW -->
    <div id="landingView" class="max-w-7xl mx-auto px-6 py-10 min-h-screen flex flex-col">
        <header class="flex justify-between items-center py-6">
            <h1 class="text-3xl font-extrabold neon-text tracking-tighter">PRICHAT // VER.1.0</h1>
            <button onclick="launchApp()" class="text-sm font-mono text-green-400/70 hover:text-green-400 transition">LAUNCH_PROTOCOL</button>
        </header>

        <main class="flex-grow flex flex-col items-center justify-center text-center">
            <div class="mb-4 px-3 py-1 border border-green-500/30 rounded-full text-xs font-mono text-green-400 bg-green-500/5">
                STATUS: ENCRYPTION_ACTIVE
            </div>
            <h2 class="text-6xl md:text-8xl font-black tracking-tight mb-8">
                SECURE CHAT<br>
                <span class="neon-text">THAT VANISHES.</span>
            </h2>
            <p class="max-w-xl text-gray-400 text-lg mb-10 leading-relaxed">
                Zero-knowledge architecture. No logs, no tracking, and rooms that self-destruct once empty. Your privacy isn't a feature; it's the core.
            </p>
            <button onclick="launchApp()" class="neon-button px-10 py-5 bg-green-500 text-black font-bold text-xl rounded-full uppercase tracking-widest">
                Initiate Session
            </button>
        </main>
        
        <footer class="py-10 text-center text-gray-600 text-xs font-mono">
            &copy; 2026 PRICHAT SYSTEM // E2E AES-GCM 256
        </footer>
    </div>

    <!-- APP VIEW -->
    <div id="appContainer" class="hidden fixed inset-0 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 z-50">
        
        <!-- ROOM ENTRY -->
        <div id="roomEntry" class="glass-card p-8 rounded-2xl w-full max-w-md shadow-2xl">
            <div class="text-center mb-8">
                <h3 class="text-2xl font-bold neon-text mb-2">Access Channel</h3>
                <p class="text-gray-400 text-sm">Enter a 6-character key to derive encryption.</p>
            </div>
            <input type="text" id="roomCode" placeholder="SECRET_KEY" 
                   class="w-full bg-gray-900 border border-green-500/30 rounded-xl p-4 text-center text-2xl font-mono text-green-400 mb-6 uppercase tracking-widest focus:outline-none focus:border-green-500" 
                   maxlength="6">
            <button id="enterRoom" class="w-full neon-button bg-green-500 text-black font-bold py-4 rounded-xl text-lg uppercase">
                Open Secure Link
            </button>
            <p id="roomEntryStatus" class="text-red-400 text-xs mt-4 text-center h-4"></p>
        </div>

        <!-- CHAT INTERFACE -->
        <div id="chatView" class="hidden glass-card w-full max-w-4xl h-[90vh] rounded-2xl flex flex-col overflow-hidden shadow-2xl border-green-500/30">
            <!-- Header -->
            <div class="p-5 border-b border-green-500/20 flex justify-between items-center bg-black/20">
                <div class="flex items-center gap-4">
                    <div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                    <div>
                        <h4 id="roomTitle" class="font-mono text-xl neon-text leading-none"></h4>
                        <p class="text-[10px] text-gray-500 uppercase mt-1">Users Connected: <span id="onlineUsersCount" class="text-green-400">0</span></p>
                    </div>
                </div>
                <button id="leaveRoom" class="px-4 py-2 border border-red-500/50 text-red-400 hover:bg-red-500 hover:text-white rounded-lg text-xs font-bold transition">TERMINATE</button>
            </div>

            <!-- Messages -->
            <div id="chatMessages" class="flex-grow p-6 flex flex-col overflow-y-auto chat-messages">
                <!-- Messages injected here -->
            </div>

            <!-- Input -->
            <div class="p-5 bg-black/30 border-t border-green-500/10">
                <form id="msgForm" class="flex gap-3">
                    <input type="text" id="messageInput" autocomplete="off" placeholder="Compose encrypted packet..." 
                           class="flex-grow bg-gray-800/50 border border-gray-700 rounded-xl px-5 py-4 focus:outline-none focus:border-green-500/50 text-white transition">
                    <button type="submit" id="sendBtn" class="neon-button bg-green-500 text-black px-8 rounded-xl font-bold">SEND</button>
                </form>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, collection, query, orderBy, onSnapshot, addDoc, setDoc, deleteDoc, serverTimestamp, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // CONFIGURATION
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'prichat-demo';
        const firebaseConfig = JSON.parse(__firebase_config || '{}');
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // STATE
        let userId = null;
        let userName = `USER_${Math.random().toString(36).substring(7).toUpperCase()}`;
        let currentRoomId = null;
        let cryptoKey = null;
        let unsubscribeMessages = null;
        let unsubscribePresence = null;

        // UI ELEMENTS
        const landingView = document.getElementById('landingView');
        const appContainer = document.getElementById('appContainer');
        const roomEntry = document.getElementById('roomEntry');
        const chatView = document.getElementById('chatView');
        const chatMessages = document.getElementById('chatMessages');

        window.launchApp = () => {
            landingView.classList.add('hidden');
            appContainer.classList.remove('hidden');
        };

        // CRYPTO ENGINE
        const deriveKey = async (code) => {
            const encoder = new TextEncoder();
            const pw = encoder.encode(code.toUpperCase());
            const salt = encoder.encode(appId);
            const keyMat = await crypto.subtle.importKey("raw", pw, "PBKDF2", false, ["deriveKey"]);
            return crypto.subtle.deriveKey(
                { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
                keyMat,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        };

        const encrypt = async (text) => {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, cryptoKey, new TextEncoder().encode(text));
            const combined = new Uint8Array(iv.length + enc.byteLength);
            combined.set(iv); 
            combined.set(new Uint8Array(enc), iv.length);
            return btoa(String.fromCharCode(...combined));
        };

        const decrypt = async (cipher) => {
            try {
                const combined = new Uint8Array(atob(cipher).split("").map(c => c.charCodeAt(0)));
                const iv = combined.slice(0, 12);
                const data = combined.slice(12);
                const dec = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, cryptoKey, data);
                return new TextDecoder().decode(dec);
            } catch (e) { return "[PACKET CORRUPTED - WRONG KEY]"; }
        };

        // FIRESTORE PATHS
        const getRoomDoc = (id) => doc(db, 'artifacts', appId, 'public', 'data', 'rooms', id);

        // MAIN LOGIC
        const joinRoom = async (roomId) => {
            // FIX: Clean up any old listeners before starting new ones
            if (unsubscribeMessages) unsubscribeMessages();
            if (unsubscribePresence) unsubscribePresence();
            
            try {
                cryptoKey = await deriveKey(roomId);
                currentRoomId = roomId;
                document.getElementById('roomTitle').textContent = `CHANNEL_${roomId}`;
                chatMessages.innerHTML = '<p class="text-center text-gray-600 text-[10px] uppercase font-mono py-10">--- Encrypted Connection Established ---</p>';

                roomEntry.classList.add('hidden');
                chatView.classList.remove('hidden');

                // Register Presence
                const userRef = doc(collection(getRoomDoc(roomId), 'users'), userId);
                await setDoc(userRef, { userId, userName, joinedAt: serverTimestamp() });

                // Listener 1: Messages
                const msgQuery = query(collection(getRoomDoc(roomId), 'messages'), orderBy('timestamp', 'asc'));
                unsubscribeMessages = onSnapshot(msgQuery, async (snap) => {
                    // Optimized: Only update if there are changes
                    if (snap.metadata.hasPendingWrites) return; 
                    
                    chatMessages.innerHTML = '';
                    for (const d of snap.docs) {
                        const data = d.data();
                        const clearText = await decrypt(data.text);
                        const msgDiv = document.createElement('div');
                        msgDiv.className = `message-bubble ${data.userId === userId ? 'mine' : 'other'}`;
                        msgDiv.innerHTML = `
                            <div class="text-[10px] font-mono opacity-70 mb-1">${data.userName}</div>
                            <div class="text-sm">${clearText}</div>
                        `;
                        chatMessages.appendChild(msgDiv);
                    }
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, (err) => console.error("Msg Error:", err));

                // Listener 2: Presence & Cleanup Logic
                unsubscribePresence = onSnapshot(collection(getRoomDoc(roomId), 'users'), (snap) => {
                    const count = snap.docs.length;
                    document.getElementById('onlineUsersCount').textContent = count;
                });

            } catch (err) {
                document.getElementById('roomEntryStatus').textContent = "CONNECTION FAILED: " + err.message;
            }
        };

        const leaveRoom = async () => {
            if (!currentRoomId || !userId) return;

            // Stop listeners immediately
            if (unsubscribeMessages) unsubscribeMessages();
            if (unsubscribePresence) unsubscribePresence();
            unsubscribeMessages = null;
            unsubscribePresence = null;

            const roomId = currentRoomId;
            const roomRef = getRoomDoc(roomId);
            const userRef = doc(collection(roomRef, 'users'), userId);

            // Remove user
            await deleteDoc(userRef);

            // Check if last user for self-destruct
            const userSnap = await getDocs(collection(roomRef, 'users'));
            if (userSnap.empty) {
                const batch = writeBatch(db);
                const msgSnap = await getDocs(collection(roomRef, 'messages'));
                msgSnap.forEach(d => batch.delete(d.ref));
                batch.delete(roomRef);
                await batch.commit();
            }

            // Reset UI
            currentRoomId = null;
            chatMessages.innerHTML = '';
            chatView.classList.add('hidden');
            roomEntry.classList.remove('hidden');
            document.getElementById('roomCode').value = '';
        };

        // EVENT HANDLERS
        document.getElementById('enterRoom').onclick = () => {
            const code = document.getElementById('roomCode').value.trim().toUpperCase();
            if (code.length === 6) joinRoom(code);
            else document.getElementById('roomEntryStatus').textContent = "ERROR: INVALID_KEY_LENGTH";
        };

        document.getElementById('msgForm').onsubmit = async (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            const val = input.value.trim();
            if (!val || !currentRoomId) return;

            const encrypted = await encrypt(val);
            input.value = '';
            
            await addDoc(collection(getRoomDoc(currentRoomId), 'messages'), {
                userId,
                userName,
                text: encrypted,
                timestamp: serverTimestamp()
            });
        };

        document.getElementById('leaveRoom').onclick = leaveRoom;

        // AUTH INITIALISATION
        onAuthStateChanged(auth, u => { if (u) userId = u.uid; });
        (async () => {
            await signInAnonymously(auth);
        })();

        // Clean up on tab close
        window.addEventListener('beforeunload', () => { if (currentRoomId) leaveRoom(); });
    </script>
</body>
</html>